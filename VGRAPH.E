function replicate(sequence pattern,integer newlength, integer offset)
    -- return sequence of length newlength generated by repetition
    -- of linear pattern, with given initial offset into pattern
    -- for *local* patterns offset is zero; for *global* patterns
    -- offset is starting location in global set of coordinates

    if offset then
    	offset = remainder(offset,length(pattern))
        newlength += offset
    end if
    while length(pattern) < newlength do
	    pattern &= pattern
    end while
    return pattern[1+offset..newlength]
end function -- replicate

function tile(          -- thanks, Colin for your help
    sequence pattern,   -- 2d patern, tile
	integer newwidth,   -- width of tiled area
	integer newheight,  -- height of tiled area
	integer xoffset,    -- left edge for global tiling
	integer yoffset     -- top edge for global tiling
    )
    -- return 2d sequence (image) of tiled area
    -- for local tiling xoffset and yoffset are zero - pattern will start
    -- in top left corner of tiled area

    if newheight <= length(pattern) then
	    pattern = replicate(pattern, newheight, yoffset)
    	for i = 1 to newheight do
    	    pattern[i] = replicate(pattern[i], newwidth, xoffset)
    	end for
    	return pattern
    else
    	for i = 1 to length(pattern) do
    	    pattern[i] = replicate(pattern[i], newwidth, xoffset)
    	end for
    	return replicate(pattern, newheight, yoffset)
    end if
end function -- tile

global procedure vclear_screen(
    atom a,         -- screen address
    integer w,      -- screen width
    integer h,      -- screen height
    integer c       -- color
    )
    -- clear virtual screen using color c
    mem_set(a,c,w*h)
end procedure

global procedure vcopy_region(
    atom a1,        -- source screen address
    integer w1,     -- source screen width
    integer x1,     -- left edge of image, source
    integer y1,     -- top edge of image, source
    integer w,      -- region width
    integer h,      -- region height
    atom a2,        -- destination screen address
    integer w2,     -- destination screen width
    integer x2,     -- left edge of image, destination
    integer y2      -- top edge of image, destination
    )
    -- copy region from screen to screen
    a1 += x1+y1*w1
    a2 += x2+y2*w2
    for row=1 to h do
        mem_copy(a2,a1,w)
        a1 += w1
        a2 += w2
    end for
end procedure

global procedure vput_image(
    atom a,         -- screen address
    integer w,      -- screen width
    integer x,      -- left edge of image
    integer y,      -- top edge of image
    sequence s      -- 2-d image
    )
    -- copy image to virtual screen
    -- use to copy background sequences, tiles, etc
    a += x+y*w
    for row=1 to length(s) do
        poke(a, s[row])
        a += w
    end for
end procedure

global function vget_image(
    atom a,         -- screen address
    integer sw,     -- screen width
    integer x,      -- left edge of image
    integer y,      -- top edge of image
    integer w,      -- image width
    integer h       -- image height
    )
    -- save image from screen into 2-dimensional sequence
    sequence s
    a += x+y*sw
    s={}
    for row=1 to h do
        s=append(s,peek({a,w}))
        a += sw
    end for
    return s
end function

global procedure vmerge_image(
    atom a,      -- screen address
    integer sw,  -- screen width
    integer x,   -- left edge of image
    integer y,   -- top edge of image
    sequence s,  -- 2-d image
    integer c   -- transparent color
    )
    -- merge image with virtual screen
    -- transparent color (see through) points of image will not be copied
    -- use to copy sprites, etc
    sequence b,si
    integer co,w
    w = length(s[1])
    a += x+y*sw
    for i=1 to length(s) do
        b = peek({a,w})           -- get background row
        si = s[i]
        for j=1 to w do
            co = si[j]
            if co = c then b[c] = co end if
        end for
        poke(a,b)
        a += w
    end for
end procedure

global procedure vpixel(
    atom a,         -- virtual screen address
    integer w,      -- virtual screen width
    object c,       -- single color value, or sequence
                    -- of consecutive color values
    sequence xy     -- xy coordinates of starting point
    )
    -- similar to pixel
    poke(a+xy[1]+w*xy[2],c)
end procedure

global procedure vtran_image_clip(atom a,integer w,integer c, sequence xy,sequence image)
integer x,y
x=0
y=0
  for i=1 to length(image) do
     for j=1 to length(image[i]) do
       if image[i][j]!=c then
         x=(xy[1]+j)
         y=(xy[2]+i)
         if x>=0 and x<=w and y>=0 and y<=480 then  
           poke(a+x+w*y,image[i][j])
         end if
       end if
     end for
  end for
end procedure

global procedure vtran_image(atom a,integer w,integer c, sequence xy,sequence image)
  for i=1 to length(image) do
     for j=1 to length(image[i]) do
       if image[i][j]!=c then
         poke(a+(xy[1]+j)+w*(xy[2]+i),image[i][j])
       end if
     end for
  end for
end procedure

global function vget_pixel(
    atom a,     -- screen address
    integer w,  -- screen width
    sequence s
    )
    -- similar to get_pixel:
    -- when s is a 2-element screen coordinate {x, y}, get_pixel()
    -- returns the color of the pixel on the pixel-graphics screen at
    -- that point
    -- when s is a 3-element sequence of the form: {x, y, n}
    -- get_pixel() returns a sequence of n color values for the points
    -- starting at {x, y} and moving to the right {x+1, y}, {x+2, y} etc.
    a += s[1]+s[2]*w
    if length(s)=3 then
        return(peek({a,s[3]}))
    else
        return(peek(a))
    end if
end function

global procedure vline(
    atom a,             -- screen address
    integer w,          -- screen width
    integer c,          -- line color
    integer x, integer y, integer x2, integer y2
    )
    -- draw line between two points
    integer ai,bi,d,wi,xi,yi,dx,dy
    if y = y2 then      -- horizontal line
        if x < x2 then
            mem_set(a+w*y+x,c,x2-x+1)
        else
            mem_set(a+w*y+x2,c,x-x2+1)
        end if
    else
        if x < x2 then
            xi = 1
            dx = x2-x
        else
           xi = -1
           dx = x-x2
        end if
        if y < y2 then
            yi = 1
            wi = w
            dy = y2-y
        else
            yi = -1
            wi = -w
            dy = y-y2
        end if
        a += w*y
        poke(a+x, c)
        if dx > dy then
            ai = 2*(dy-dx)
            bi = 2*dy
            d = bi-dx
            while x != x2 do
                if d>=0 then
                    a += wi
                    d += ai
                else
                    d += bi
                end if
                x += xi
                poke(a+x,c)
            end while
        else
            ai=2*(dx-dy)
            bi=2*dx
            d=bi-dy
            while y != y2 do
                if d>=0 then
                    x += xi
                    d += ai
                else
                    d += bi
                end if
                y += yi
                a += wi
                poke(a+x,c)
            end while
        end if
    end if
end procedure

global procedure vlines(
    atom a,         -- screen address
    integer w,      -- screen width
    integer c,      -- color
    sequence p      -- {{x1,y1},{x2,y2},...{xn,yn}}
    )
    -- similar to draw_line
    for i=1 to length(p)-1 do
        vline(a,w,c,p[i][1],p[i][2],p[i+1][1],p[i+1][2])
    end for
end procedure

global procedure vbox(
    atom a,         -- screen address
    integer sw,     -- screen width
    object c,       -- single color value, or 2-d pattern
    integer f,      -- fill flag: 0/1 -> hollow/filled
    integer x,      -- left edge
    integer y,      -- top edge
    integer w,      -- width
    integer h       -- height
    )
    sequence s
    a+=x+y*sw
    if f then           -- draw solid rectangle
        if atom(c) then -- single color fill
            for i=1 to h do
                mem_set(a,c,w)
                a+=sw
            end for
        else            -- tiled
            s = tile(c,w,h,x,y)
            for i=1 to h do
                poke(a,s[i])
                a+=sw
            end for
        end if
    else                    -- draw hollow rectangle
        mem_set(a,c,w)      -- top horizontal line
        a+=sw
        for i=2 to h-1 do
            poke(a,c)       -- left vertical line
            poke(a+w-1,c)   -- right vertical line
            a+=sw
        end for
        mem_set(a,c,w)      -- bottom horizontal line
    end if
end procedure -- vbox